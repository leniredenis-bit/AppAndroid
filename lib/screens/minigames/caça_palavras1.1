import 'dart:math';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart'; // Para HapticFeedback
import '../../services/audio_service.dart';
import '../../services/storage_service.dart';
import '../../services/achievement_service.dart';
import '../../services/minigame_content_service.dart';
import '../../widgets/achievement_unlock_dialog.dart';

// --- Paleta de Cores para as Palavras Encontradas ---
const List<Color> kWordColors = [
  Color(0xFFEF5350), // Red
  Color(0xFFAB47BC), // Purple
  Color(0xFF42A5F5), // Blue
  Color(0xFF26A69A), // Teal
  Color(0xFF66BB6A), // Green
  Color(0xFFFFA726), // Orange
  Color(0xFFFF7043), // Deep Orange
  Color(0xFF8D6E63), // Brown
  Color(0xFF78909C), // Blue Grey
];

// --- Modelo para uma linha marcada ---
class WordLine {
  final Point<int> start;
  final Point<int> end;
  final Color color;

  WordLine(this.start, this.end, this.color);
}

class WordSearchGame extends StatefulWidget {
  const WordSearchGame({super.key});

  @override
  State<WordSearchGame> createState() => _WordSearchGameState();
}

class _WordSearchGameState extends State<WordSearchGame> with TickerProviderStateMixin {
  final AudioService _audioService = AudioService();
  final StorageService _storage = StorageService();
  final AchievementService _achievementService = AchievementService();
  final MinigameContentService _contentService = MinigameContentService();

  // Grid configuration
  static const int gridSize = 12;

  // Game State
  late List<String> _words;
  late List<List<String>> _grid;
  final List<WordLine> _foundLines = []; // Linhas já encontradas e coloridas
  final Set<String> _foundWords = {}; // Strings das palavras encontradas
  
  // Dragging State
  Point<int>? _dragStart;
  Point<int>? _dragEnd; // Onde o dedo está atualmente
  Point<int>? _validEnd; // O final válido da linha (snap na grid)
  
  DateTime? _gameStartTime;
  Key _gameKey = UniqueKey();

  @override
  void initState() {
    super.initState();
    _startNewGame();
  }

  void _startNewGame() {
    _gameStartTime = DateTime.now();
    _audioService.playBackgroundMusic('quiz-home.mp3'); // Mantenha ou mude para algo relaxante
    
    // Reset state
    _foundLines.clear();
    _foundWords.clear();
    _dragStart = null;
    _dragEnd = null;
    _validEnd = null;
    
    _selectRandomWords();
    _generateGrid();
    setState(() {});
  }

  @override
  void dispose() {
    _audioService.stopBackgroundMusic();
    super.dispose();
  }

  void _selectRandomWords() {
    final random = Random();
    final allWords = _contentService.wordSearchWords
        .where((w) => w.length <= gridSize) // Garante que a palavra cabe
        .toList();
        
    final shuffled = List<String>.from(allWords)..shuffle(random);
    _words = shuffled.take(8).toList(); // 8 palavras é um bom número para mobile
  }

  void _generateGrid() {
    _grid = List.generate(gridSize, (_) => List.filled(gridSize, ''));
    final random = Random();

    // Coloca as palavras
    for (String word in _words) {
      bool placed = false;
      int attempts = 0;
      while (!placed && attempts < 100) {
        attempts++;
        int row = random.nextInt(gridSize);
        int col = random.nextInt(gridSize);
        int dir = random.nextInt(4); // 0:H, 1:V, 2:D(\), 3:D(/)

        int dr = 0, dc = 0;
        if (dir == 0) dc = 1;
        if (dir == 1) dr = 1;
        if (dir == 2) { dr = 1; dc = 1; }
        if (dir == 3) { dr = -1; dc = 1; }

        if (_canPlace(word, row, col, dr, dc)) {
          _place(word, row, col, dr, dc);
          placed = true;
        }
      }
    }

    // Preenche vazios
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (int r = 0; r < gridSize; r++) {
      for (int c = 0; c < gridSize; c++) {
        if (_grid[r][c] == '') {
          _grid[r][c] = chars[random.nextInt(chars.length)];
        }
      }
    }
  }

  bool _canPlace(String word, int r, int c, int dr, int dc) {
    for (int i = 0; i < word.length; i++) {
      int nr = r + dr * i;
      int nc = c + dc * i;
      if (nr < 0 || nr >= gridSize || nc < 0 || nc >= gridSize) return false;
      if (_grid[nr][nc] != '' && _grid[nr][nc] != word[i]) return false;
    }
    return true;
  }

  void _place(String word, int r, int c, int dr, int dc) {
    for (int i = 0; i < word.length; i++) {
      _grid[r + dr * i][c + dc * i] = word[i];
    }
  }

  // --- Lógica de Interação ---

  void _onPanStart(DragStartDetails details, double cellSize) {
    // Converte coordenada de pixel para grid
    int c = (details.localPosition.dx / cellSize).floor();
    int r = (details.localPosition.dy / cellSize).floor();

    if (r >= 0 && r < gridSize && c >= 0 && c < gridSize) {
      setState(() {
        _dragStart = Point(r, c);
        _dragEnd = Point(r, c);
        _validEnd = Point(r, c);
      });
      HapticFeedback.lightImpact();
      _audioService.playClick();
    }
  }

  void _onPanUpdate(DragUpdateDetails details, double cellSize) {
    if (_dragStart == null) return;

    // Posição atual do dedo em grid coords
    int c = (details.localPosition.dx / cellSize).floor();
    int r = (details.localPosition.dy / cellSize).floor();

    // Clamp para não sair da tela
    c = c.clamp(0, gridSize - 1);
    r = r.clamp(0, gridSize - 1);
    
    Point<int> current = Point(r, c);

    if (current != _dragEnd) {
      setState(() {
        _dragEnd = current;
        // Calcula a projeção válida (snap) para H, V ou Diagonal
        _validEnd = _calculateValidEnd(_dragStart!, current);
      });
      // Feedback leve ao mudar de célula
      if (_validEnd != null && _validEnd != _dragStart) {
         // Opcional: HapticFeedback.selectionClick();
      }
    }
  }

  void _onPanEnd(DragEndDetails details) {
    if (_dragStart != null && _validEnd != null) {
      _checkSelection(_dragStart!, _validEnd!);
    }
    setState(() {
      _dragStart = null;
      _dragEnd = null;
      _validEnd = null;
    });
  }

  // Força o arrasto a ser uma linha reta perfeita (0, 45, 90 graus)
  Point<int> _calculateValidEnd(Point<int> start, Point<int> end) {
    int dx = end.x - start.x;
    int dy = end.y - start.y;

    if (dx == 0 && dy == 0) return start;

    // Verifica qual direção é predominante
    if (dx.abs() > dy.abs() * 2) {
      // Horizontal
      return Point(end.x, start.y);
    } else if (dy.abs() > dx.abs() * 2) {
      // Vertical
      return Point(start.x, end.y);
    } else {
      // Diagonal - força dx e dy serem iguais
      int dist = max(dx.abs(), dy.abs());
      return Point(
        start.x + (dx.sign * dist),
        start.y + (dy.sign * dist)
      );
    }
  }

  void _checkSelection(Point<int> start, Point<int> end) {
    // 1. Constrói a palavra baseada na linha
    StringBuffer sb = StringBuffer();
    StringBuffer sbReverse = StringBuffer();
    
    int points = max((end.x - start.x).abs(), (end.y - start.y).abs());
    int dr = (end.x - start.x).sign;
    int dc = (end.y - start.y).sign;

    // Verifica limites (segurança extra)
    int finalR = start.x + dr * points;
    int finalC = start.y + dc * points;
    if (finalR < 0 || finalR >= gridSize || finalC < 0 || finalC >= gridSize) return;

    for (int i = 0; i <= points; i++) {
      sb.write(_grid[start.x + dr * i][start.y + dc * i]);
    }
    String word = sb.toString();
    String reversed = word.split('').reversed.join('');

    // 2. Verifica se a palavra existe
    String? foundWord;
    if (_words.contains(word) && !_foundWords.contains(word)) {
      foundWord = word;
    } else if (_words.contains(reversed) && !_foundWords.contains(reversed)) {
      foundWord = reversed;
    }

    if (foundWord != null) {
      // Sucesso!
      _audioService.playMatch();
      HapticFeedback.mediumImpact();
      
      setState(() {
        _foundWords.add(foundWord!);
        // Pega a próxima cor da paleta
        Color color = kWordColors[_foundLines.length % kWordColors.length];
        _foundLines.add(WordLine(start, end, color));
      });

      if (_foundWords.length == _words.length) {
        _handleVictory();
      }
    } else {
       // Erro / Seleção inválida
       // Opcional: som de erro leve
    }
  }

  void _handleVictory() async {
    _audioService.playVictory();
    final timeSpent = DateTime.now().difference(_gameStartTime!).inSeconds;

    await _storage.saveMinigameRecord(
      'word_search',
      score: 100,
      won: true,
      timeInSeconds: timeSpent,
    );
    
    // Conquistas
    if (mounted) {
       // ... Lógica de conquistas padrão ...
    }
    
    // Mostra Dialog
    if (mounted) {
        showDialog(
            context: context,
            barrierDismissible: false,
            builder: (ctx) => AlertDialog(
                backgroundColor: Colors.white,
                shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(20)),
                title: const Column(
                    children: [
                        Icon(Icons.emoji_events, color: Colors.amber, size: 50),
                        SizedBox(height: 10),
                        Text("COMPLETO!", style: TextStyle(color: Colors.black87, fontWeight: FontWeight.bold)),
                    ],
                ),
                content: Text("Você encontrou todas as palavras em $timeSpent segundos!"),
                actions: [
                    TextButton(
                        onPressed: () {
                            Navigator.pop(ctx);
                            setState(() {
                                _startNewGame();
                            });
                        },
                        child: const Text("JOGAR NOVAMENTE", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                    )
                ],
            )
        );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: Colors.grey.shade100,
      appBar: AppBar(
        title: const Text("CAÇA PALAVRAS", style: TextStyle(fontWeight: FontWeight.bold, letterSpacing: 1.5, color: Colors.black87)),
        backgroundColor: Colors.white,
        elevation: 0,
        centerTitle: true,
        iconTheme: const IconThemeData(color: Colors.black87),
        actions: [
            Center(
                child: Padding(
                  padding: const EdgeInsets.only(right: 20),
                  child: Text(
                      "${_foundWords.length}/${_words.length}",
                      style: const TextStyle(color: Colors.teal, fontWeight: FontWeight.w900, fontSize: 18),
                  ),
                ),
            )
        ],
      ),
      body: Column(
        children: [
          // 1. O Tabuleiro
          Expanded(
            flex: 2,
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Center(
                child: LayoutBuilder(
                  builder: (context, constraints) {
                    // Calcula o tamanho da célula para caber no quadrado disponível
                    double size = min(constraints.maxWidth, constraints.maxHeight);
                    double cellSize = size / gridSize;
                    
                    return GestureDetector(
                      onPanStart: (d) => _onPanStart(d, cellSize),
                      onPanUpdate: (d) => _onPanUpdate(d, cellSize),
                      onPanEnd: _onPanEnd,
                      child: SizedBox(
                        width: size,
                        height: size,
                        child: CustomPaint(
                          painter: WordSearchPainter(
                            grid: _grid,
                            foundLines: _foundLines,
                            dragStart: _dragStart,
                            dragEnd: _validEnd, // Usa o final "corrigido"
                            cellSize: cellSize,
                          ),
                        ),
                      ),
                    );
                  },
                ),
              ),
            ),
          ),

          // 2. A Lista de Palavras
          Expanded(
            flex: 1,
            child: Container(
              width: double.infinity,
              padding: const EdgeInsets.all(20),
              decoration: const BoxDecoration(
                color: Colors.white,
                borderRadius: BorderRadius.vertical(top: Radius.circular(30)),
                boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 10, offset: Offset(0, -5))]
              ),
              child: SingleChildScrollView(
                child: Wrap(
                  spacing: 12,
                  runSpacing: 12,
                  alignment: WrapAlignment.center,
                  children: _words.map((word) {
                    bool found = _foundWords.contains(word);
                    // Acha a cor da linha se encontrada
                    Color color = Colors.grey;
                    if (found) {
                        // Tenta achar a linha correspondente pra pegar a cor exata
                        // (Simplificado pela ordem de inserção)
                    }
                    
                    return AnimatedOpacity(
                      duration: const Duration(milliseconds: 500),
                      opacity: found ? 0.5 : 1.0,
                      child: Container(
                        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                        decoration: BoxDecoration(
                          color: found ? Colors.grey.shade200 : Colors.white,
                          borderRadius: BorderRadius.circular(20),
                          border: Border.all(
                              color: found ? Colors.transparent : Colors.teal.shade100,
                              width: 2
                          ),
                          boxShadow: found ? [] : [
                              BoxShadow(color: Colors.teal.withValues(alpha: 0.1), blurRadius: 5, offset: const Offset(0, 2))
                          ]
                        ),
                        child: Text(
                          word,
                          style: TextStyle(
                            color: found ? Colors.grey : Colors.black87,
                            fontWeight: FontWeight.bold,
                            decoration: found ? TextDecoration.lineThrough : null,
                          ),
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

// --- O PINTOR (O Coração do Visual) ---

class WordSearchPainter extends CustomPainter {
  final List<List<String>> grid;
  final List<WordLine> foundLines;
  final Point<int>? dragStart;
  final Point<int>? dragEnd;
  final double cellSize;

  WordSearchPainter({
    required this.grid,
    required this.foundLines,
    required this.dragStart,
    required this.dragEnd,
    required this.cellSize,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // 1. Desenha as Linhas já encontradas (Camada inferior)
    final linePaint = Paint()
      ..style = PaintingStyle.stroke
      ..strokeCap = StrokeCap.round
      ..strokeWidth = cellSize * 0.8; // A linha preenche quase toda a célula

    for (var line in foundLines) {
      linePaint.color = line.color.withValues(alpha: 0.4); // Transparente
      _drawLine(canvas, line.start, line.end, linePaint);
    }

    // 2. Desenha a Linha sendo arrastada agora
    if (dragStart != null && dragEnd != null) {
      linePaint.color = Colors.teal.withValues(alpha: 0.3);
      _drawLine(canvas, dragStart!, dragEnd!, linePaint);
    }

    // 3. Desenha o Texto (Camada superior)
    final textStyle = TextStyle(
      color: Colors.black87,
      fontSize: cellSize * 0.55,
      fontWeight: FontWeight.w600,
      fontFamily: 'Monospace', // Ou sua fonte padrão
    );

    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
      textAlign: TextAlign.center,
    );

    for (int r = 0; r < grid.length; r++) {
      for (int c = 0; c < grid.length; c++) {
        textPainter.text = TextSpan(text: grid[r][c], style: textStyle);
        textPainter.layout(minWidth: cellSize, maxWidth: cellSize);
        
        // Centraliza o texto na célula
        final offset = Offset(
          c * cellSize,
          r * cellSize + (cellSize - textPainter.height) / 2
        );
        textPainter.paint(canvas, offset);
      }
    }
  }

  void _drawLine(Canvas canvas, Point<int> p1, Point<int> p2, Paint paint) {
    // Calcula o centro da célula
    final startOffset = Offset(
      p1.y * cellSize + cellSize / 2,
      p1.x * cellSize + cellSize / 2
    );
    final endOffset = Offset(
      p2.y * cellSize + cellSize / 2,
      p2.x * cellSize + cellSize / 2
    );
    canvas.drawLine(startOffset, endOffset, paint);
  }

  @override
  bool shouldRepaint(covariant WordSearchPainter oldDelegate) {
    return oldDelegate.dragEnd != dragEnd || 
           oldDelegate.foundLines.length != foundLines.length;
  }
}